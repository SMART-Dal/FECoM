import pickle
import requests
import sys
sys.path.append('../../../server')
from send_request import send_request

def custom_method(func, imports: str, function_to_run: str, method_object=None, function_args: list=None, function_kwargs: dict=None, max_wait_secs=0, custom_class=None):
    result = send_request(imports, function_to_run, function_args, function_kwargs, max_wait_secs, method_object)
    return func
import tensorflow as tf
import numpy as np
import math, random
import matplotlib.pyplot as plt
from pprint.xyz.abc import pprint as ppr
import torch
import torchvision
import torchvision.transforms as transforms
from torch import trans
from pt import trans as tf2
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
from os.path import exists
import sys
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from tensorflow.keras.layers import Dense, Dropout as drop
from tensorflow.keras.layers import *
import tensorflow.keras.backend as K
import tensorflow.keras.layers as L
import tensorflow.compat.v1 as tf
from tensorflow.keras.layers import Dense, Dropout, Conv2D
from tensorflow.keras.backend import clear_session, set_session
from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv
custom_method(
tf(), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='tf()', method_object=None, function_args=[], function_kwargs={}, max_wait_secs=30)
testlist = ['a', 'b', 'c']
X = custom_method(
tf.placeholder(tf.float32, [None, 1], name='X'), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='tf.placeholder(*args, **kwargs)', method_object=None, function_args=[eval('tf.float32'), eval('[None, 1]')], function_kwargs={'name': eval('"X"')}, max_wait_secs=30)
Y = custom_method(
tf.placeholder(tf.float32, [None, 1], name='Y'), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='tf.placeholder(*args, **kwargs)', method_object=None, function_args=[eval('tf.float32'), eval('[None, 1]')], function_kwargs={'name': eval('"Y"')}, max_wait_secs=30)
z = custom_method(
tf.value('aname', bname, name='tname'), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='tf.value(*args, **kwargs)', method_object=None, function_args=[eval('"aname"'), eval('bname')], function_kwargs={'name': eval('"tname"')}, max_wait_secs=30)
w_o = custom_method(
tf.Variable(tf.random_uniform([layer_1_neurons, 1], minval=-1, maxval=1, dtype=tf.float32), test1, test2, test3='test3'), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='tf.Variable(*args, **kwargs)', method_object=None, function_args=[eval('tf.random_uniform([layer_1_neurons, 1], minval = -1, maxval = 1, dtype = tf.float32)'), eval('test1'), eval('test2')], function_kwargs={'test3': eval('"test3"')}, max_wait_secs=30)
b_o = custom_method(
tf.Variable(tf.zeros([1, 1], dtype=tf.float32)), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='tf.Variable(*args)', method_object=None, function_args=[eval('tf.zeros([1, 1], dtype = tf.float32)')], function_kwargs={}, max_wait_secs=30)
cd = ab.test(a, b)
c_o = custom_method(
xf.test(), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='obj.test()', method_object='xf', function_args=[], function_kwargs={}, max_wait_secs=30, custom_class=None)
d_o = custom_method(
xy.test(), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='obj.test()', method_object='xy', function_args=[], function_kwargs={}, max_wait_secs=30, custom_class=None)
model = custom_method(
tf.keras.models.Sequential([tf.keras.layers.Flatten(input_shape=(28, 28)), tf.keras.layers.Dense(128, activation='relu'), tf.keras.layers.Dropout(0.2), tf.keras.layers.Dense(10)]), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='tf.keras.models.Sequential(*args)', method_object=None, function_args=[eval("[\n    tf.keras.layers.Flatten(input_shape=(28, 28)),\n    tf.keras.layers.Dense(128, activation='relu'),\n    tf.keras.layers.Dropout(0.2),\n    tf.keras.layers.Dense(10)\n    ]")], function_kwargs={}, max_wait_secs=30)
custom_method(
model.compile(), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='obj.compile()', method_object='model', function_args=[], function_kwargs={}, max_wait_secs=30, custom_class=None)
f_o = custom_method(
b_o.test.compile(), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='obj.test.compile()', method_object='b_o', function_args=[], function_kwargs={}, max_wait_secs=30, custom_class=None)
z_o = c_o.compile()
import torch
import torchvision
import torchvision.transforms as transforms
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
transform = custom_method(
transforms.Compose([transforms.ToTensor(), transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))]), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='transforms.Compose(*args)', method_object=None, function_args=[eval('[transforms.ToTensor(),\n     transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))]')], function_kwargs={}, max_wait_secs=30)
batch_size = 4
trainset = custom_method(
torchvision.datasets.CIFAR10(root='./data', train=True, download=True, transform=transform), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='torchvision.datasets.CIFAR10(**kwargs)', method_object=None, function_args=[], function_kwargs={'root': eval("'./data'"), 'train': eval('True'), 'download': eval('True'), 'transform': eval('transform')}, max_wait_secs=30)
trainloader = custom_method(
torch.utils.data.DataLoader(trainset, batch_size=batch_size, shuffle=True, num_workers=0), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='torch.utils.data.DataLoader(*args, **kwargs)', method_object=None, function_args=[eval('trainset')], function_kwargs={'batch_size': eval('batch_size'), 'shuffle': eval('True'), 'num_workers': eval('0')}, max_wait_secs=30)
testset = custom_method(
torchvision.datasets.CIFAR10(root='./data', train=False, download=True, transform=transform), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='torchvision.datasets.CIFAR10(**kwargs)', method_object=None, function_args=[], function_kwargs={'root': eval("'./data'"), 'train': eval('False'), 'download': eval('True'), 'transform': eval('transform')}, max_wait_secs=30)
testloader = custom_method(
torch.utils.data.DataLoader(testset, batch_size=batch_size, shuffle=False, num_workers=0), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='torch.utils.data.DataLoader(*args, **kwargs)', method_object=None, function_args=[eval('testset')], function_kwargs={'batch_size': eval('batch_size'), 'shuffle': eval('False'), 'num_workers': eval('0')}, max_wait_secs=30)
classes = ('plane', 'car', 'bird', 'cat', 'deer', 'dog', 'frog', 'horse', 'ship', 'truck')

class Net(nn.Module, abc.Module):

    def __init__(self):
        super().__init__()
        self.conv1 = custom_method(
        nn.Conv2d(3, 6, 5), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='nn.Conv2d(*args)', method_object=None, function_args=[eval('3'), eval('6'), eval('5')], function_kwargs={}, max_wait_secs=30)
        self.pool = custom_method(
        nn.MaxPool2d(2, 2), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='nn.MaxPool2d(*args)', method_object=None, function_args=[eval('2'), eval('2')], function_kwargs={}, max_wait_secs=30)
        self.conv2 = custom_method(
        nn.Conv2d(6, 16, 5), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='nn.Conv2d(*args)', method_object=None, function_args=[eval('6'), eval('16'), eval('5')], function_kwargs={}, max_wait_secs=30)
        self.fc1 = custom_method(
        nn.Linear(16 * 5 * 5, 120), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='nn.Linear(*args)', method_object=None, function_args=[eval('16 * 5 * 5'), eval('120')], function_kwargs={}, max_wait_secs=30)
        self.fc2 = custom_method(
        nn.Linear(120, 84), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='nn.Linear(*args)', method_object=None, function_args=[eval('120'), eval('84')], function_kwargs={}, max_wait_secs=30)
        self.fc3 = custom_method(
        nn.Linear(84, 10), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='nn.Linear(*args)', method_object=None, function_args=[eval('84'), eval('10')], function_kwargs={}, max_wait_secs=30)

    def forward(self, x):
        x = self.pool(F.relu(self.conv1(x)))
        x = self.pool(F.relu(self.conv2(x)))
        x = custom_method(
        torch.flatten(x, 1), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='torch.flatten(*args)', method_object=None, function_args=[eval('x'), eval('1')], function_kwargs={}, max_wait_secs=30)
        x = custom_method(
        F.relu(self.fc1(x)), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='F.relu(*args)', method_object=None, function_args=[eval('self.fc1(x)')], function_kwargs={}, max_wait_secs=30)
        x = custom_method(
        F.relu(self.fc2(x)), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='F.relu(*args)', method_object=None, function_args=[eval('self.fc2(x)')], function_kwargs={}, max_wait_secs=30)
        x = self.fc3(x)
        return x

class dummyClass(abc.tf.keras.layers.Layer, abc.nn.Module):

    def __init__(self):
        self.dummy = 0

    def dummyFunc(self):
        self.dummy += 1
        return self.dummy

class dummyClass2:

    def __init__(self):
        self.dummy = 0

    def dummyFunc(self):
        self.dummy += 1
        return self.dummy
net = Net()

class MyDenseLayer(tf.keras.layers.Layer, nn.Module):

    def __init__(self, num_outputs):
        custom_method(
        super(MyDenseLayer, self).__init__(), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='super(MyDenseLayer, self).__init__()', method_object=None, function_args=[], function_kwargs={}, max_wait_secs=30)
        self.num_outputs = num_outputs

    def build(self, input_shape):
        self.kernel = self.add_weight('kernel', shape=[int(input_shape[-1]), self.num_outputs])

    def call(self, inputs):
        return custom_method(
        tf.matmul(inputs, self.kernel), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='tf.matmul(*args)', method_object=None, function_args=[eval('inputs'), eval('self.kernel')], function_kwargs={}, max_wait_secs=30)
layer = custom_method(
MyDenseLayer(10), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='MyDenseLayer(*args)', method_object=None, function_args=[eval('10')], function_kwargs={}, max_wait_secs=30)
criterion = custom_method(
nn.CrossEntropyLoss(), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='nn.CrossEntropyLoss()', method_object=None, function_args=[], function_kwargs={}, max_wait_secs=30)
optimizer = custom_method(
optim.SGD(net.parameters(), lr=0.001, momentum=0.9), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='optim.SGD(*args, **kwargs)', method_object=None, function_args=[eval('net.parameters()')], function_kwargs={'lr': eval('0.001'), 'momentum': eval('0.9')}, max_wait_secs=30)
for epoch in range(2):
    running_loss = 0.0
    for (i, data) in enumerate(trainloader, 0):
        (inputs, labels) = data
        custom_method(
        optimizer.zero_grad(), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='optimizer.zero_grad()', method_object=None, function_args=[], function_kwargs={}, max_wait_secs=30)
        outputs = custom_method(
        net(inputs), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='obj(*args)', method_object='net', function_args=[eval('inputs')], function_kwargs={}, max_wait_secs=30, custom_class='class Net(nn.Module, abc.Module):\n    def __init__(self):\n        super().__init__()\n        self.conv1 = nn.Conv2d(3, 6, 5)\n        self.pool = nn.MaxPool2d(2, 2)\n        self.conv2 = nn.Conv2d(6, 16, 5)\n        self.fc1 = nn.Linear(16 * 5 * 5, 120)\n        self.fc2 = nn.Linear(120, 84)\n        self.fc3 = nn.Linear(84, 10)\n\n    def forward(self, x):\n        x = self.pool(F.relu(self.conv1(x)))\n        x = self.pool(F.relu(self.conv2(x)))\n        x = torch.flatten(x, 1) # flatten all dimensions except batch\n        x = F.relu(self.fc1(x))\n        x = F.relu(self.fc2(x))\n        x = self.fc3(x)\n        return x')
        loss = custom_method(
        criterion(outputs, labels), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='obj(*args)', method_object='criterion', function_args=[eval('outputs'), eval('labels')], function_kwargs={}, max_wait_secs=30, custom_class=None)
        loss.backward()
        custom_method(
        optimizer.step(), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='optimizer.step()', method_object=None, function_args=[], function_kwargs={}, max_wait_secs=30)
        running_loss += loss.item()
        if i % 2000 == 1999:
            print(f'[{epoch + 1}, {i + 1:5d}] loss: {running_loss / 2000:.3f}')
            running_loss = 0.0
print('Finished Training')
PATH = './cifar_net.pth'
custom_method(
torch.save(net.state_dict(), PATH), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='torch.save(*args)', method_object=None, function_args=[eval('net.state_dict()'), eval('PATH')], function_kwargs={}, max_wait_secs=30)
dataiter = iter(testloader)
(images, labels) = custom_method(
next(dataiter), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='obj(*args)', method_object='next', function_args=[eval('dataiter')], function_kwargs={}, max_wait_secs=30, custom_class=None)
net = Net()
custom_method(
net.load_state_dict(torch.load(PATH)), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='obj.load_state_dict(*args)', method_object='net', function_args=[eval('torch.load(PATH)')], function_kwargs={}, max_wait_secs=30, custom_class='class Net(nn.Module, abc.Module):\n    def __init__(self):\n        super().__init__()\n        self.conv1 = nn.Conv2d(3, 6, 5)\n        self.pool = nn.MaxPool2d(2, 2)\n        self.conv2 = nn.Conv2d(6, 16, 5)\n        self.fc1 = nn.Linear(16 * 5 * 5, 120)\n        self.fc2 = nn.Linear(120, 84)\n        self.fc3 = nn.Linear(84, 10)\n\n    def forward(self, x):\n        x = self.pool(F.relu(self.conv1(x)))\n        x = self.pool(F.relu(self.conv2(x)))\n        x = torch.flatten(x, 1) # flatten all dimensions except batch\n        x = F.relu(self.fc1(x))\n        x = F.relu(self.fc2(x))\n        x = self.fc3(x)\n        return x')
outputs = custom_method(
net(images), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='obj(*args)', method_object='net', function_args=[eval('images')], function_kwargs={}, max_wait_secs=30, custom_class='class Net(nn.Module, abc.Module):\n    def __init__(self):\n        super().__init__()\n        self.conv1 = nn.Conv2d(3, 6, 5)\n        self.pool = nn.MaxPool2d(2, 2)\n        self.conv2 = nn.Conv2d(6, 16, 5)\n        self.fc1 = nn.Linear(16 * 5 * 5, 120)\n        self.fc2 = nn.Linear(120, 84)\n        self.fc3 = nn.Linear(84, 10)\n\n    def forward(self, x):\n        x = self.pool(F.relu(self.conv1(x)))\n        x = self.pool(F.relu(self.conv2(x)))\n        x = torch.flatten(x, 1) # flatten all dimensions except batch\n        x = F.relu(self.fc1(x))\n        x = F.relu(self.fc2(x))\n        x = self.fc3(x)\n        return x')
(_, predicted) = custom_method(
torch.max(outputs, 1), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='torch.max(*args)', method_object=None, function_args=[eval('outputs'), eval('1')], function_kwargs={}, max_wait_secs=30)
print('Predicted: ', ' '.join((f'{classes[predicted[j]]:5s}' for j in range(4))))
correct = 0
total = 0
with custom_method(
torch.no_grad(), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='torch.no_grad()', method_object=None, function_args=[], function_kwargs={}, max_wait_secs=30):
    for data in testloader:
        (images, labels) = data
        outputs = custom_method(
        net(images), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='obj(*args)', method_object='net', function_args=[eval('images')], function_kwargs={}, max_wait_secs=30, custom_class='class Net(nn.Module, abc.Module):\n    def __init__(self):\n        super().__init__()\n        self.conv1 = nn.Conv2d(3, 6, 5)\n        self.pool = nn.MaxPool2d(2, 2)\n        self.conv2 = nn.Conv2d(6, 16, 5)\n        self.fc1 = nn.Linear(16 * 5 * 5, 120)\n        self.fc2 = nn.Linear(120, 84)\n        self.fc3 = nn.Linear(84, 10)\n\n    def forward(self, x):\n        x = self.pool(F.relu(self.conv1(x)))\n        x = self.pool(F.relu(self.conv2(x)))\n        x = torch.flatten(x, 1) # flatten all dimensions except batch\n        x = F.relu(self.fc1(x))\n        x = F.relu(self.fc2(x))\n        x = self.fc3(x)\n        return x')
        (_, predicted) = custom_method(
        torch.max(outputs.data, 1), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='torch.max(*args)', method_object=None, function_args=[eval('outputs.data'), eval('1')], function_kwargs={}, max_wait_secs=30)
        total += labels.size(0)
        correct += (predicted == labels).sum().item()
print(f'Accuracy of the network on the 10000 test images: {100 * correct // total} %')
correct_pred = {classname: 0 for classname in classes}
total_pred = {classname: 0 for classname in classes}
with custom_method(
torch.no_grad(), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='torch.no_grad()', method_object=None, function_args=[], function_kwargs={}, max_wait_secs=30):
    for data in testloader:
        (images, labels) = data
        outputs = custom_method(
        net(images), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='obj(*args)', method_object='net', function_args=[eval('images')], function_kwargs={}, max_wait_secs=30, custom_class='class Net(nn.Module, abc.Module):\n    def __init__(self):\n        super().__init__()\n        self.conv1 = nn.Conv2d(3, 6, 5)\n        self.pool = nn.MaxPool2d(2, 2)\n        self.conv2 = nn.Conv2d(6, 16, 5)\n        self.fc1 = nn.Linear(16 * 5 * 5, 120)\n        self.fc2 = nn.Linear(120, 84)\n        self.fc3 = nn.Linear(84, 10)\n\n    def forward(self, x):\n        x = self.pool(F.relu(self.conv1(x)))\n        x = self.pool(F.relu(self.conv2(x)))\n        x = torch.flatten(x, 1) # flatten all dimensions except batch\n        x = F.relu(self.fc1(x))\n        x = F.relu(self.fc2(x))\n        x = self.fc3(x)\n        return x')
        (_, predictions) = custom_method(
        torch.max(outputs, 1), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='torch.max(*args)', method_object=None, function_args=[eval('outputs'), eval('1')], function_kwargs={}, max_wait_secs=30)
        for (label, prediction) in custom_method(
        zip(labels, predictions), imports='import torchvision;from os.path import exists;from torch import trans;from tensorflow.keras import layers;import tensorflow as tf;import math, random;import sys;import matplotlib.pyplot as plt;from pt import trans as tf2;import tensorflow.keras.backend as K;import torchvision.transforms as transforms;import numpy as np;from tensorflow.keras.layers import Dense as dense_layer, Dropout as drop, Conv2D as conv;from tensorflow.keras.layers import Dense, Dropout, Conv2D;from tensorflow.keras.layers import Dense, Dropout as drop;import torch;import torch.optim as optim;import torch.nn as nn;from tensorflow.keras.layers import *;from pprint.xyz.abc import pprint as ppr;from tensorflow import keras;import torch.nn.functional as F;import tensorflow.keras.layers as L;import tensorflow.compat.v1 as tf;from tensorflow.keras.backend import clear_session, set_session', function_to_run='obj(*args)', method_object='zip', function_args=[eval('labels'), eval('predictions')], function_kwargs={}, max_wait_secs=30, custom_class=None):
            if label == prediction:
                correct_pred[classes[label]] += 1
            total_pred[classes[label]] += 1
for (classname, correct_count) in correct_pred.items():
    accuracy = 100 * float(correct_count) / total_pred[classname]
    print(f'Accuracy for class: {classname:5s} is {accuracy:.1f} %')
